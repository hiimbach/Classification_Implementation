import torch
import os
import sys
import PIL
import cv2
import numpy as np

from PIL import Image
from torchvision import transforms

ROOT = os.getcwd()
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))
    
from model.resnet import ResNet50
from utils.data_loader import custom_loader, filenames_to_tensor, read_file_classnames


class MushroomClassifier():
    def __init__(self, file_names_path=None, weight_path=None, model_path=None):
        '''
        Arguments:
            file_names_path (str): The path to the file name, generated by utils.TrainLoop,
                                    structured as name1, name2, name3,... 
            weight_path (str): The path of ResNet50 checkpoint
            model_path (str): The path of the scripted model
        
        '''
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        if model_path:
            self.model = torch.jit.load(model_path)
        else:
            self.model = ResNet50(9)
            if weight_path:
                self.model.load_state_dict(torch.load(weight_path, map_location=device))
                
        self.class_names = None
        if file_names_path:
            self.class_names = read_file_classnames(file_names_path)
            
        self.tf = transforms.Compose([
            transforms.Resize((224, 224)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])])
        
        self.model.eval()
        
        
    @torch.inference_mode()
    def predict(self, path, batch_size=4) -> int:
        if not os.path.exists(path):
            print("Not found path")
            return 
        else:
            # If there is a image
            if os.path.isfile(path):
                img = Image.open(path)
                tensor = self.tf(img)
                tensor.unsqueeze_(dim=0)
                
                out = self.model(tensor)
                _, preds = torch.max(out, dim=1)
                if self.class_names:
                    return {path: self.class_names[int(preds[0])]}
                else: 
                    return {path: int(preds[0])}
            
            # If the path is a folder 
            elif os.path.isdir(path):
                all_paths = [os.path.join(path, file) for file in os.listdir(path)]
                
                # Load data into batches
                path_batches = custom_loader(all_paths, batch_size)
                all_preds = []
                for path_batch in path_batches:
                    tensor = filenames_to_tensor(path_batch, self.tf)
                    out = self.model(tensor)
                    _, preds = torch.max(out, dim=1)
                    all_preds += (preds.tolist())
                
                result = {}
                for i in range(len(all_paths)):
                    if self.class_names:
                        result[all_paths[i]] = self.class_names[all_preds[i]]
                    else:
                        result[all_paths[i]] = all_preds[i]
                    
                return result
                    
            else:
                print("Path must belongs to an image or a folder")
                return    
                    
    @torch.inference_mode()
    def predict_from_image(self, img:np.ndarray, use_cv2=False) -> int:
        if bool(use_cv2):
            img = img[:,:,::-1]
        to_pil = transforms.ToPILImage()
        tensor = self.tf(to_pil(img))
        tensor.unsqueeze_(dim=0)
        
        out = self.model(tensor)
        _, preds = torch.max(out, dim=1)
        if self.class_names:
            return self.class_names[int(preds[0])]
        else: 
            return int(preds[0])


if __name__ == '__main__':
    class_names_path = 'model/scripted_model/resnet50/class_names.txt'
    classifier = MushroomClassifier(model_path='model/scripted_model/resnet50/scripted_model.pt')
    origin_path = "data/mushrooms/Suillus"
    result = classifier.predict(origin_path)
    print(result)
    